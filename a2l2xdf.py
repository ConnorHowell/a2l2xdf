import csv

from pya2l import DB, model
from pya2l.api import inspect
from sys import argv
from xml.etree.ElementTree import Element, SubElement, Comment, ElementTree

BASE_OFFSET = 0xA0800000

db = DB()
#session = db.import_a2l(argv[1])
session = db.open_existing(argv[1])

data_sizes = {
    'UWORD' : 2,
    'UBYTE' : 1,
    'SBYTE' : 1,
    'SWORD' : 2,
    'ULONG': 4,
    'SLONG': 4,
    'FLOAT32_IEEE': 4
}

# XDF Serialization methods

def xdf_root_with_configuration(title):
    root = Element('XDFFORMAT')
    root.set('version', '1.60')

    xdfheader = SubElement(root, 'XDFHEADER')
    flags = SubElement(xdfheader, 'flags')
    flags.text = "0x1"
    deftitle = SubElement(xdfheader, "deftitle")
    deftitle.text = title
    description = SubElement(xdfheader, "description")
    description.text = "Auto-generated by A2L2XDF"
    baseoffset = SubElement(xdfheader, "BASEOFFSET")
    baseoffset.set('offset', '0')
    baseoffset.set('subtract', '0')
    defaults = SubElement(xdfheader, 'DEFAULTS')
    defaults.set('datasizeinbits', '8')
    defaults.set('sigdigits', '4')
    defaults.set('outputtype', '1')
    defaults.set('signed', '0')
    defaults.set('lsbfirst', '1')
    defaults.set('float', '0')
    region = SubElement(xdfheader, "REGION")
    region.set('type', '0xFFFFFFFF')
    region.set('startaddress', '0x0')
    region.set('size', '0x7D000')
    region.set('regionflags', '0x0')
    region.set('name', 'Binary')
    region.set('desc', 'BIN for the XDF')
    return [root, xdfheader]

def xdf_axis_with_table(table: Element, id, axis_def):
    axis = SubElement(table, "XDFAXIS")
    axis.set('uniqueid', '0x0')
    axis.set('id', id)
    embeddeddata = SubElement(axis, 'EMBEDDEDDATA')
    embeddeddata.set('mmedtypeflags', '0x02' if id != "z" else '0x06')
    embeddeddata.set('mmedaddress', str(axis_def['address']))
    embeddeddata.set('mmedelementsizebits', str(data_sizes[axis_def['dataSize']] * 8))
    embeddeddata.set('mmedcolcount', str(axis_def['length']) if 'length' in axis_def else "1")
    if(id == "z"):
        embeddeddata.set('mmedrowcount', str(axis_def['rows']) if 'rows' in axis_def else "1")
    embeddeddata.set('mmedmajorstridebits', str(data_sizes[axis_def['dataSize']] * 8))
    embeddeddata.set('mmedminorstridebits', '0')
    indexcount = SubElement(axis, 'indexcount')
    indexcount.text = str(axis_def['length']) if 'length' in axis_def else "1"
    min = SubElement(axis, 'min')
    min.text = str(axis_def['min'])
    max = SubElement(axis, 'max')
    max.text = str(axis_def['max'])
    units = SubElement(axis, 'units')
    units.text = axis_def['units']
    embedinfo = SubElement(axis, 'embedinfo')
    embedinfo.set('type', '1') # "Pure, Internal"
    dalink = SubElement(axis, 'DALINK')
    dalink.set('index', '0')
    math = SubElement(axis, 'MATH')
    math.set('equation', axis_def['math'])
    var = SubElement(math, 'VAR')
    var.set('id', 'X')
    return axis

def xdf_table_with_root(root: Element, table_def):
    table = SubElement(root, 'XDFTABLE')
    table.set('uniqueid', table_def['z']['address'])
    table.set('flags', '0x30')
    title = SubElement(table, 'title')
    title.text = table_def['title']
    description = SubElement(table, 'description')
    description.text = table_def['description']
    categorymem = SubElement(table, 'CATEGORYMEM')
    categorymem.set('index', "0")
    categorymem.set('category', str(table_def['category'] + 1))
    return table

def xdf_category(xdfheader: Element, category_name, category_index):
    category = SubElement(xdfheader, "CATEGORY")
    category.set('index', hex(category_index))
    category.set('name', category_name)
    return category

# Helpers

def calc_map_size(characteristic: inspect.Characteristic):
    data_size = data_sizes[characteristic.deposit.fncValues['datatype']]
    map_size = data_size
    for axis_ref in characteristic.axisDescriptions:
        map_size *= axis_ref.maxAxisPoints
    return map_size
def adjust_address(address):
    return address - BASE_OFFSET

# A2L to "normal" conversion methods

dummy_axis = {
    'min': 1,
    'max': 1,
    'address': 0x0,
    'units': '-',
    'length': 1,
    'dataSize': 'UBYTE',
    'math': 'X'
}

def axis_ref_to_points(axis_ref: inspect.AxisDescr):
    axis_value = {
        'units': axis_ref.axisPtsRef.compuMethod.unit,
        'min': axis_ref.lowerLimit,
        'max': axis_ref.upperLimit,
        'address': hex(adjust_address(axis_ref.axisPtsRef.address) + data_sizes[axis_ref.axisPtsRef.depositAttr.axisPts['x']['datatype']]), # We need to offset the axis by 1 value, the first value is another length
        'length': axis_ref.maxAxisPoints,
        'dataSize': axis_ref.axisPtsRef.depositAttr.axisPts['x']['datatype']
    }
    if(len(axis_ref.compuMethod.coeffs) > 0):
        axis_value['math'] = coefficients_to_equation(axis_ref.compuMethod.coeffs)
    else:
        axis_value['math'] = "X"
    return axis_value

def coefficients_to_equation(coefficients):
    a, b, c, d, e, f = str(coefficients["a"]), str(coefficients["b"]), str(coefficients["c"]), str(coefficients["d"]), str(coefficients["e"]), str(coefficients["f"])
    if (a == "0.0" and d == "0.0"): # Polynomial is of order 1, ie linear
        return (f'(({f} * X) - {c} ) / ({b} - ({e} * X))')
    else:
        return ("Cannot handle polynomial ratfunc because we do not know how to invert!")

# Begin

root, xdfheader = xdf_root_with_configuration(argv[1])

categories = []

with open(argv[2]) as csvfile:
     csvreader = csv.reader(csvfile)
     for row in csvreader:
        tablename = row[1]
        if tablename == "Table Name":
            continue
        characteristics = session.query(model.Characteristic).order_by(model.Characteristic.name).filter(model.Characteristic.name == tablename).first()
        if(characteristics is None):
            print("******** Could not find ! ", tablename)
            continue
        c_data = inspect.Characteristic(session, tablename)
        table_offset = adjust_address(c_data.address)
        table_length = calc_map_size(c_data)
        axisDescriptions = c_data.axisDescriptions
        
        category = row[0]
        if category not in categories:
            categories.append(category)
            index = categories.index(category)
            xdf_category(xdfheader, category, index)

        table_def = {
            'title': c_data.longIdentifier,
            'description': c_data.name, 
            'category': categories.index(category),
            'z': {
                'min': c_data.lowerLimit,
                'max': c_data.upperLimit,
                'address': hex(adjust_address(c_data.address)),
                'dataSize': c_data.deposit.fncValues['datatype'],
                'units': c_data.compuMethod.unit
            }
        }
        
        if(len(c_data.compuMethod.coeffs) > 0):
            table_def['z']['math'] = coefficients_to_equation(c_data.compuMethod.coeffs)
        else:
            table_def['z']['math'] = "X"
        
        if len(axisDescriptions) > 0:
            table_def['x'] = axis_ref_to_points(axisDescriptions[0])
            table_def['z']['length'] = table_def['x']['length']
        if len(axisDescriptions) > 1:
            table_def['y'] = axis_ref_to_points(axisDescriptions[1])
            table_def['z']['rows'] = table_def['y']['length']

        table = xdf_table_with_root(root, table_def)
        
        if('x' in table_def):
            xdf_axis_with_table(table, 'x', table_def['x'])
        else:
            xdf_axis_with_table(table, 'x', dummy_axis)
        
        if('y' in table_def):
            xdf_axis_with_table(table, 'y', table_def['y'])
        else:
            xdf_axis_with_table(table, 'y', dummy_axis)
        
        xdf_axis_with_table(table, 'z', table_def['z'])

ElementTree(root).write(f'{argv[1]}.xdf')
